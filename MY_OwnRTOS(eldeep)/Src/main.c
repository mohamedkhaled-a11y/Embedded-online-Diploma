/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x8.h"
#include "stm32f103x8_gpio_driver.h"
#include "lcd.h"
#include "keypad.h"
#include "stm32f103x8_EXTI_driver.h"
#include "stm32f103x8_USART_driver.h"
#include "stm32f103x8_SPI_driver.h"
#include "stm32f103x8_I2C_driver.h"
#include "I2C_Slave_EEPROM.h"
#include "core_cm3.h"
#include "schedular.h"


Task_ref task1 , task2 ,task3 ,task4;

unsigned char Task1_LED,Task2_LED,Task3_LED  ,Task4_LED;


Mutex_ref mutx1;
Mutex_ref mutx2;
unsigned char payload[3] = {0,1,2};
unsigned char payload2[3] = {0,1,2};



void Task1()
{

	static int count =0;
	while(1)
	{
		Task1_LED ^=1;
		count++;
		if(count==100)
		{
			Aquire_Mutex(&mutx1,&task1);
			RTOS_Activate_Task(&task2);
		//	Aquire_Mutex(&mutx2, &task1);

		}

		if(count==200)
		{
			Release_Mutex(&mutx1);
			count=0;
		}

	}


}

void Task2()
{

	static int count =0;
	while(1)
	{
		Task2_LED ^=1;

		count++;
		if(count==100)
		{
			RTOS_Activate_Task(&task3);
		}

		if(count ==200)
		{
			RTOS_Terminate_Task(&task2);
			count =0;


		}

	}

}



void Task3()
{

	static int count =0;
	while(1)
	{

		Task3_LED ^=1;

		count++;
		if(count==100)
		{
			RTOS_Activate_Task(&task4);
		}

		if(count ==200)
		{
			count =0;
			RTOS_Terminate_Task(&task3);

		}



	}

}




void Task4()
{

	static int count=0;
	while(1)
	{
		Task4_LED ^=1;
		count++;

		if(count==3)
		{
		//	Aquire_Mutex(&mutx2,&task4);
			Aquire_Mutex(&mutx1,&task4);
		}

		if(count ==200)
		{
			count =0;
			Release_Mutex(&mutx1);
			RTOS_Terminate_Task(&task4);



		}

	}

}




int main(void)
{

	MYRTOS_errorID ER;

	if(RTOS_Init()!=NO_ERROR)
		while(1);


	 RTOS_Creat_Mutex(&mutx1,payload ,3,"MUTEX1");
	 RTOS_Creat_Mutex(&mutx2,payload2 ,3,"MUTEX2");


	ER+= RTOS_Define_Task(&task1,1024,Task1,4,"TASK_1");
	ER+= RTOS_Define_Task(&task2,1024,Task2,3,"TASK_2");
	ER+= RTOS_Define_Task(&task3,1024,Task3,2,"TASK_3");
	ER+= RTOS_Define_Task(&task4,1024,Task4,1,"TASK_4");


	RTOS_Activate_Task(&task1);
	//RTOS_Activate_Task(&task2);
	//RTOS_Activate_Task(&task3);

	MYRTOS_STARTOS();

	while(1);


}

